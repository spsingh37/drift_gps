<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DRIFT: Other Communication Wrappers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DRIFT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Other Communication Wrappers </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Although we provided a ROS wrapper inside our repository, users can actually write their own communication wrappers according to their needs. The only requirement is that the wrapper should be able to send and receive messages to and from the robot or simulator. In this tutorial, we will show you how to write a communication wrapper. The wrapper includes three parts: message types, communication subscriber, and communication publisher. It is relatively simple once you understan the framework.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Step 1: Create custom message types if necessary</h2>
<p>Although most of the time, you can use the message types provided by the simulator or robot, sometimes you may need to create your own message types. For example, in our case, we need to create <code>contact</code> related messages for the MIT mini-cheetah robot. In this case, we created the new message types by following the <a href="http://wiki.ros.org/ROS/Tutorials/CreatingMsgAndSrv">ROS tutorial</a> and put them under <code>drift/ROS/drift/msg</code> folder. After creating the message type, the <code>./build_ros.sh</code> script will automatically build the message types. The specific lines of message builder is shown below: </p><div class="fragment"><div class="line">MSG_NAMESPACE=custom_sensor_msgs</div>
<div class="line">MSG_PATH=./ROS/drift/msg</div>
<div class="line">MSG_HEADER_OUTPUT_PATH=./ROS/drift/include/$MSG_NAMESPACE/</div>
<div class="line"> </div>
<div class="line">for file in $MSG_PATH/*</div>
<div class="line">do</div>
<div class="line">  if [[ -a $file ]]</div>
<div class="line">  then</div>
<div class="line">    rosrun gencpp gen_cpp.py -p $MSG_NAMESPACE -o $MSG_HEADER_OUTPUT_PATH -e /opt/ros/noetic/share/gencpp &quot;$file&quot; -I std_msgs:/opt/ros/noetic/share/std_msgs/msg -I $MSG_NAMESPACE:$MSG_PATH</div>
<div class="line">  fi</div>
<div class="line">done</div>
</div><!-- fragment --><p>If you need to use other communication methods, please refer to corresponding documentation on how to build custom message types.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Step 2: Create a new communication subscriber class</h2>
<p>A communication subscriber mainly acts like an interface between robot/simulator messages and filter defined measurement types. The subscriber should be able to receive messages from the robot/simulator, and push them into corresponding sensor data buffers. In our filter, we used <code>std::queue&lt;std::shared_ptr&lt;TYPE&gt;&gt;</code> to be the sensor data buffer type. For example, when an IMU message comes in, the IMU subscriber should be able to convert the IMU message to <code>ImuMeasurement&lt;double&gt;</code> type and push it into a <code>std::queue&lt;std::shared_ptr&lt;ImuMeasurement&lt;double&gt;&gt;&gt;</code> data buffer. Because this data buffer is also shared with the filter interface on a different thread, a common <code>std::mutex</code> is required to protect the data sharing between threads. The following code snippet shows how we implemented the IMU subscriber in ROS. More examples can be found in <code><a class="el" href="ros__subscriber_8cpp.html">ros_subscriber.cpp</a></code>. </p><div class="fragment"><div class="line"><span class="comment">// Use a function to add a new IMU subscriber</span></div>
<div class="line"><a class="code hl_typedef" href="ros__subscriber_8h.html#a21a48d02eceb8daac4166e966d384de4">IMUQueuePair</a> ROSSubscriber::AddIMUSubscriber(<span class="keyword">const</span> std::string topic_name) {</div>
<div class="line">  <span class="comment">// Create a new queue for data buffers</span></div>
<div class="line">  <a class="code hl_typedef" href="type__def_8h.html#ac57b15fb1e344a7041a287e5d13e1b00">IMUQueuePtr</a> imu_queue_ptr(<span class="keyword">new</span> <a class="code hl_typedef" href="type__def_8h.html#ac033f1b84fab28142a37626bde293295">IMUQueue</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize a new mutex for this subscriber</span></div>
<div class="line">  mutex_list_.emplace_back(<span class="keyword">new</span> std::mutex);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create the subscriber</span></div>
<div class="line">  subscriber_list_.push_back(nh_-&gt;subscribe&lt;sensor_msgs::Imu&gt;(</div>
<div class="line">      topic_name, 1000,</div>
<div class="line">      boost::bind(&amp;ROSSubscriber::IMUCallback, <span class="keyword">this</span>, _1, mutex_list_.back(),</div>
<div class="line">                  imu_queue_ptr)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Keep the ownership of the data queue in this class</span></div>
<div class="line">  imu_queue_list_.push_back(imu_queue_ptr);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> {imu_queue_ptr, mutex_list_.back()};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The true function that handles IMU message</span></div>
<div class="line"><span class="keywordtype">void</span> ROSSubscriber::IMUCallback(</div>
<div class="line">    <span class="keyword">const</span> boost::shared_ptr&lt;const sensor_msgs::Imu&gt;&amp; imu_msg,</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;std::mutex&gt;&amp; mutex, <a class="code hl_typedef" href="type__def_8h.html#ac57b15fb1e344a7041a287e5d13e1b00">IMUQueuePtr</a>&amp; imu_queue) {</div>
<div class="line">  <span class="comment">// Create an imu measurement object</span></div>
<div class="line">  std::shared_ptr&lt;ImuMeasurement&lt;double&gt;&gt; imu_measurement(</div>
<div class="line">      <span class="keyword">new</span> ImuMeasurement&lt;double&gt;);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set headers and time stamps</span></div>
<div class="line">  imu_measurement-&gt;set_header(</div>
<div class="line">      imu_msg-&gt;header.seq,</div>
<div class="line">      imu_msg-&gt;header.stamp.sec + imu_msg-&gt;header.stamp.nsec / 1000000000.0,</div>
<div class="line">      imu_msg-&gt;header.frame_id);</div>
<div class="line">  <span class="comment">// Set angular velocity</span></div>
<div class="line">  imu_measurement-&gt;set_angular_velocity(imu_msg-&gt;angular_velocity.x,</div>
<div class="line">                               imu_msg-&gt;angular_velocity.y,</div>
<div class="line">                               imu_msg-&gt;angular_velocity.z);</div>
<div class="line">  <span class="comment">// Set linear acceleration</span></div>
<div class="line">  imu_measurement-&gt;set_lin_acc(imu_msg-&gt;linear_acceleration.x,</div>
<div class="line">                               imu_msg-&gt;linear_acceleration.y,</div>
<div class="line">                               imu_msg-&gt;linear_acceleration.z);</div>
<div class="line">  <span class="comment">// Set orientation estimate</span></div>
<div class="line">  <span class="comment">// Check if IMU has quaternion data:</span></div>
<div class="line">  <span class="keywordflow">if</span> (Eigen::Vector4d({imu_msg-&gt;orientation.w, imu_msg-&gt;orientation.x,</div>
<div class="line">                       imu_msg-&gt;orientation.y, imu_msg-&gt;orientation.z})</div>
<div class="line">          .norm()</div>
<div class="line">      != 0) {</div>
<div class="line">    imu_measurement-&gt;set_quaternion(</div>
<div class="line">        imu_msg-&gt;orientation.w, imu_msg-&gt;orientation.x, imu_msg-&gt;orientation.y,</div>
<div class="line">        imu_msg-&gt;orientation.z);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  mutex.get()-&gt;lock();</div>
<div class="line">  imu_queue-&gt;push(imu_measurement);</div>
<div class="line">  mutex.get()-&gt;unlock();</div>
<div class="line">}</div>
<div class="ttc" id="aros__subscriber_8h_html_a21a48d02eceb8daac4166e966d384de4"><div class="ttname"><a href="ros__subscriber_8h.html#a21a48d02eceb8daac4166e966d384de4">IMUQueuePair</a></div><div class="ttdeci">std::pair&lt; IMUQueuePtr, std::shared_ptr&lt; std::mutex &gt; &gt; IMUQueuePair</div><div class="ttdef"><b>Definition:</b> ros_subscriber.h:49</div></div>
<div class="ttc" id="atype__def_8h_html_ac033f1b84fab28142a37626bde293295"><div class="ttname"><a href="type__def_8h.html#ac033f1b84fab28142a37626bde293295">IMUQueue</a></div><div class="ttdeci">std::queue&lt; ImuMeasurementPtr &gt; IMUQueue</div><div class="ttdef"><b>Definition:</b> type_def.h:51</div></div>
<div class="ttc" id="atype__def_8h_html_ac57b15fb1e344a7041a287e5d13e1b00"><div class="ttname"><a href="type__def_8h.html#ac57b15fb1e344a7041a287e5d13e1b00">IMUQueuePtr</a></div><div class="ttdeci">std::shared_ptr&lt; IMUQueue &gt; IMUQueuePtr</div><div class="ttdef"><b>Definition:</b> type_def.h:52</div></div>
</div><!-- fragment --><p> Users can also create their own way in building subscribers. But please make sure that the message type is converted to the measurement type defined in the filter.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Step 3: Create a new communication publisher class</h2>
<p>A publisher class is actually optional. If a user simply wants to have the poses saved into a file, she/he can simply write the pose data from <code>RobotStateQueue</code> buffer into a <code>.txt</code> file. But having a publisher offers the ability to monitor the path output in realtime.</p>
<p>The publisher class is much simpler than the subscriber class. This class acts as an interface between filter output and visualizable messages. The filter output is stored in a data buffer of type <code>RobotStateQueue</code>, which is <code>std::queue&lt;std::shared_ptr&lt;RobotState&gt;&gt;</code>. The publisher class's job is to read data from the buffer and use user prefered communication method to publish the data. In our case with ROS communication, the publisher converts the state estimate message to <code>geometry_msgs::PoseStamped</code> type. Because we also want to have a visulizable path shown in RVIZ, the message is also pushed into a <code>std::vector&lt;geometry_msgs::PoseStamped&gt;</code> data buffer, which will be constructed into a <code>nav_msgs::Path</code> message. Because <code>RobotState</code> data buffer is also shared with the filter interface on a different thread, a common <code>std::mutex</code> is required to protect the data sharing between threads. The following code snippet shows how we implemented the publisher class in ROS. Header file can be found in <code><a class="el" href="ros__publisher_8h.html" title="Header file for ROS publisher class.">ros_publisher.h</a></code>. </p><div class="fragment"><div class="line">```cpp</div>
<div class="line"><span class="comment">/* ----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Copyright 2023, CURLY Lab, University of Michigan</span></div>
<div class="line"><span class="comment"> * All Rights Reserved</span></div>
<div class="line"><span class="comment"> * See LICENSE for the license information</span></div>
<div class="line"><span class="comment"> * -------------------------------------------------------------------------- */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ros__publisher_8h.html">communication/ros_publisher.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceros__wrapper.html">ros_wrapper</a> {</div>
<div class="line"><a class="code hl_function" href="classros__wrapper_1_1ROSPublisher.html#ae94ee6271552f7ee8e66fe639d9515a9">ROSPublisher::ROSPublisher</a>(ros::NodeHandle* nh,</div>
<div class="line">                           <a class="code hl_typedef" href="type__def_8h.html#a64c0065bd95d5bc87f07b183e516aa95">RobotStateQueuePtr</a>&amp; robot_state_queue_ptr,</div>
<div class="line">                           std::shared_ptr&lt;std::mutex&gt; robot_state_queue_mutex)</div>
<div class="line">    : nh_(nh),</div>
<div class="line">      robot_state_queue_ptr_(robot_state_queue_ptr),</div>
<div class="line">      robot_state_queue_mutex_(robot_state_queue_mutex),</div>
<div class="line">      thread_started_(false) {</div>
<div class="line">  std::string pose_topic;</div>
<div class="line">  std::string path_topic;</div>
<div class="line">  nh_-&gt;param&lt;std::string&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/pose_topic&quot;</span>, pose_topic,</div>
<div class="line">                          <span class="stringliteral">&quot;/robot/inekf_estimation/pose&quot;</span>);</div>
<div class="line">  nh_-&gt;param&lt;std::string&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/map_frame_id&quot;</span>, pose_frame_,</div>
<div class="line">                          <span class="stringliteral">&quot;/odom&quot;</span>);</div>
<div class="line">  nh-&gt;param&lt;std::string&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/path_topic&quot;</span>, path_topic,</div>
<div class="line">                         <span class="stringliteral">&quot;/robot/inekf_estimation/path&quot;</span>);</div>
<div class="line">  nh_-&gt;param&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/pose_publish_rate&quot;</span>,</div>
<div class="line">                     pose_publish_rate_, 1000);</div>
<div class="line">  nh_-&gt;param&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/path_publish_rate&quot;</span>,</div>
<div class="line">                     path_publish_rate_, 1000);</div>
<div class="line">  nh_-&gt;param&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;/curly_state_est_settings/pose_skip&quot;</span>, pose_skip_, 1);</div>
<div class="line">  first_pose_ = {0, 0, 0};</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;pose_topic: &quot;</span> &lt;&lt; pose_topic &lt;&lt; <span class="stringliteral">&quot;, pose publish rate: &quot;</span> &lt;&lt; pose_publish_rate &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;path_topic: &quot;</span> &lt;&lt; path_topic &lt;&lt; <span class="stringliteral">&quot;, path publish rate: &quot;</span> &lt;&lt; path_publish_rate_ &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  pose_pub_ = nh_-&gt;advertise&lt;geometry_msgs::PoseWithCovarianceStamped&gt;(</div>
<div class="line">      pose_topic, 1000);</div>
<div class="line">  path_pub_ = nh_-&gt;advertise&lt;nav_msgs::Path&gt;(path_topic, 1000);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ROSPublisher::~ROSPublisher() {</div>
<div class="line">  <span class="keywordflow">if</span> (thread_started_ == <span class="keyword">true</span>) {</div>
<div class="line">    pose_publishing_thread_.join();</div>
<div class="line">    path_publishing_thread_.join();</div>
<div class="line">  }</div>
<div class="line">  poses_.clear();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ROSPublisher::StartPublishingThread() {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;start publishing thread&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  this-&gt;pose_publishing_thread_</div>
<div class="line">      = std::thread([<span class="keyword">this</span>] { this-&gt;PosePublishingThread(); });</div>
<div class="line">  this-&gt;path_publishing_thread_</div>
<div class="line">      = std::thread([<span class="keyword">this</span>] { this-&gt;PathPublishingThread(); });</div>
<div class="line"> </div>
<div class="line">  thread_started_ = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publishes pose</span></div>
<div class="line"><span class="keywordtype">void</span> ROSPublisher::PosePublish() {</div>
<div class="line">  <span class="keywordflow">if</span> (robot_state_queue_ptr_-&gt;empty()) {</div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;pose queue is empty&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the first pose</span></div>
<div class="line">  robot_state_queue_mutex_.get()-&gt;lock();</div>
<div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;RobotState&gt; state_ptr = robot_state_queue_ptr_-&gt;front();</div>
<div class="line">  robot_state_queue_ptr_-&gt;pop();</div>
<div class="line">  robot_state_queue_mutex_.get()-&gt;unlock();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> RobotState&amp; <a class="code hl_namespace" href="namespacestate.html">state</a> = *state_ptr.get();</div>
<div class="line"> </div>
<div class="line">  geometry_msgs::PoseWithCovarianceStamped pose_msg;</div>
<div class="line">  <span class="comment">// Header msg</span></div>
<div class="line">  pose_msg.header.seq = pose_seq_;</div>
<div class="line">  pose_msg.header.stamp = ros::Time().fromSec(<a class="code hl_namespace" href="namespacestate.html">state</a>.get_time());</div>
<div class="line">  pose_msg.header.frame_id = pose_frame_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Pose msg</span></div>
<div class="line">  pose_msg.pose.pose.position.x</div>
<div class="line">      = <a class="code hl_namespace" href="namespacestate.html">state</a>.get_world_position()(0) - first_pose_[0];</div>
<div class="line">  pose_msg.pose.pose.position.y</div>
<div class="line">      = <a class="code hl_namespace" href="namespacestate.html">state</a>.get_world_position()(1) - first_pose_[1];</div>
<div class="line">  pose_msg.pose.pose.position.z</div>
<div class="line">      = <a class="code hl_namespace" href="namespacestate.html">state</a>.get_world_position()(2) - first_pose_[2];</div>
<div class="line"> </div>
<div class="line">  Eigen::Quaterniond quat(<a class="code hl_namespace" href="namespacestate.html">state</a>.get_world_rotation());</div>
<div class="line">  pose_msg.pose.pose.orientation.w = quat.w();</div>
<div class="line">  pose_msg.pose.pose.orientation.x = quat.x();</div>
<div class="line">  pose_msg.pose.pose.orientation.y = quat.y();</div>
<div class="line">  pose_msg.pose.pose.orientation.z = quat.z();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Covariance msg</span></div>
<div class="line">  <span class="keyword">auto</span>&amp; cov = <a class="code hl_namespace" href="namespacestate.html">state</a>.get_P();</div>
<div class="line">  <span class="comment">// Get the 6x6 covariance matrix in the following order:</span></div>
<div class="line">  <span class="comment">// (x, y, z, rotation about X axis, rotation about Y axis, rotation</span></div>
<div class="line">  <span class="comment">// about Z axis)</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 6; i++) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 6; j++) {</div>
<div class="line">      pose_msg.pose.covariance[i * 6 + j] = cov(i, j);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  pose_pub_.publish(pose_msg);</div>
<div class="line">  pose_seq_++;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(pose_seq_) % pose_skip_ == 0) {</div>
<div class="line">    geometry_msgs::PoseStamped pose_stamped;</div>
<div class="line">    pose_stamped.header = pose_msg.header;</div>
<div class="line">    pose_stamped.pose = pose_msg.pose.pose;</div>
<div class="line"> </div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(poses_mutex_);</div>
<div class="line">    poses_.push_back(pose_stamped);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pose publishing thread</span></div>
<div class="line"><span class="keywordtype">void</span> ROSPublisher::PosePublishingThread() {</div>
<div class="line">  <span class="comment">// Loop and publish data</span></div>
<div class="line">  ros::Rate loop_rate(pose_publish_rate_);</div>
<div class="line">  <span class="keywordflow">while</span> (ros::ok()) {</div>
<div class="line">    PosePublish();</div>
<div class="line">    loop_rate.sleep();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publishes path</span></div>
<div class="line"><span class="keywordtype">void</span> ROSPublisher::PathPublish() {</div>
<div class="line">  std::lock_guard&lt;std::mutex&gt; lock(poses_mutex_);</div>
<div class="line">  <span class="keywordflow">if</span> (poses_.size() == 0) {</div>
<div class="line">    <span class="comment">// std::cout &lt;&lt; &quot;path is empty&quot; &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  nav_msgs::Path path_msg;</div>
<div class="line">  path_msg.header.seq = path_seq_;</div>
<div class="line">  path_msg.header.stamp = poses_.back().header.stamp;</div>
<div class="line">  <span class="comment">// path_msg.header.stamp = ros::Time::now();</span></div>
<div class="line">  path_msg.header.frame_id = pose_frame_;</div>
<div class="line">  path_msg.poses = poses_;</div>
<div class="line"> </div>
<div class="line">  path_pub_.publish(pa  th_msg);</div>
<div class="line">  path_seq_++;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Path publishing thread</span></div>
<div class="line"><span class="keywordtype">void</span> ROSPublisher::PathPublishingThread() {</div>
<div class="line">  <span class="comment">// Loop and publish data</span></div>
<div class="line">  ros::Rate loop_rate(path_publish_rate_);</div>
<div class="line">  <span class="keywordflow">while</span> (ros::ok()) {</div>
<div class="line">    PathPublish();</div>
<div class="line">    loop_rate.sleep();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}    <span class="comment">// namespace ros_wrapper</span></div>
<div class="ttc" id="aclassros__wrapper_1_1ROSPublisher_html_ae94ee6271552f7ee8e66fe639d9515a9"><div class="ttname"><a href="classros__wrapper_1_1ROSPublisher.html#ae94ee6271552f7ee8e66fe639d9515a9">ros_wrapper::ROSPublisher::ROSPublisher</a></div><div class="ttdeci">ROSPublisher(ros::NodeHandle *nh, RobotStateQueuePtr &amp;robot_state_queue, std::shared_ptr&lt; std::mutex &gt; robot_state_queue_mutex, bool enable_slip_publisher_=false)</div><div class="ttdoc">Construct a new ROS Publisher object.</div><div class="ttdef"><b>Definition:</b> ros_publisher.cpp:18</div></div>
<div class="ttc" id="anamespaceros__wrapper_html"><div class="ttname"><a href="namespaceros__wrapper.html">ros_wrapper</a></div><div class="ttdef"><b>Definition:</b> ros_publisher.cpp:17</div></div>
<div class="ttc" id="anamespacestate_html"><div class="ttname"><a href="namespacestate.html">state</a></div><div class="ttdef"><b>Definition:</b> robot_state.cpp:18</div></div>
<div class="ttc" id="aros__publisher_8h_html"><div class="ttname"><a href="ros__publisher_8h.html">ros_publisher.h</a></div><div class="ttdoc">Header file for ROS publisher class.</div></div>
<div class="ttc" id="atype__def_8h_html_a64c0065bd95d5bc87f07b183e516aa95"><div class="ttname"><a href="type__def_8h.html#a64c0065bd95d5bc87f07b183e516aa95">RobotStateQueuePtr</a></div><div class="ttdeci">std::shared_ptr&lt; RobotStateQueue &gt; RobotStateQueuePtr</div><div class="ttdef"><b>Definition:</b> type_def.h:34</div></div>
</div><!-- fragment --><p> Once the above three steps are finished, user may finish up writing the main function as well as the CMakelists.txt file. You are also more than welcome to share your wrapper to our repo by creating a pull request!</p>
<p>Enjoy! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
